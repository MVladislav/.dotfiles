#!/usr/bin/env bash

PATH="/usr/bin/:/usr/local/bin/:/bin:/usr/sbin/:/sbin:/snap/bin/:$HOME/.local/bin"
set -euo pipefail
IFS=$'\n\t'

# ******************************************************************************

RUN_WITH_SUDO=''
IS_SUDO_INSTALL=0
if command -v sudo &>/dev/null; then
  RUN_WITH_SUDO=sudo
  IS_SUDO_INSTALL=1
fi

# ******************************************************************************

# COLOR ------------------------------------------------------------------------
# https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux)
NC='\033[0m'         # No Color
BRED='\033[1;31m'    # Red
BPURPLE='\033[1;35m' # Purple
BYELLOW='\033[1;33m' # Yellow
BCYAN='\033[1;36m'   # Cyan

# ******************************************************************************

: "${VM_SEC_TMP:="${HOME}/.tmp"}" # /tmp

# shellcheck disable=SC2034
DEPS_INSTALL_PATH="${VM_SEC_TMP}"
USER_LOCAL_PREFIX="${HOME}/.local"
USER_LOCAL_PREFIX_BIN="$USER_LOCAL_PREFIX/bin"

DEPS_PACKAGES_TO_REMOVE=()

# shellcheck disable=SC2034
INSTALL_SOURCE_FROM=release # source | release

# ******************************************************************************

print_info() { echo -e "${BPURPLE}$1${NC}"; }
print_info2() { echo -e "${BYELLOW}$1${NC}"; }
print_read() { printf "%b%s%b" "${BYELLOW}" "$1" "${NC}"; }
print_notes() { echo -e "${BCYAN}$1${NC}"; }
print_error() { echo -e "${BRED}$1${NC}" >&2; }

# ******************************************************************************

install_dependencies_needs() {
  print_notes "   üì• Installing build dependencies..."
  DEPS_PACKAGES_TO_REMOVE=()

  local -n tools_ref="${1%\[@\]}"
  local -n build_ref="${2%\[@\]}"
  local packages_tools=("${tools_ref[@]}")
  local packages_build=("${build_ref[@]}")

  local packages_to_install=()

  # Check packages_tools: install if missing, but never mark for removal.
  for pkg in "${packages_tools[@]}"; do
    if ! apt list -qq "$pkg" 2>/dev/null | grep -q 'installed'; then
      packages_to_install+=("$pkg")
    fi
    # # TODO: possible speedup
    # if ! dpkg -l | grep -q "^ii  $pkg "; then
    #   packages_to_install+=("$pkg")
    # fi
  done

  # Check packages_build: install if missing and add to removal list.
  for pkg in "${packages_build[@]}"; do
    if ! apt list -qq "$pkg" 2>/dev/null | grep -q 'installed'; then
      packages_to_install+=("$pkg")
      DEPS_PACKAGES_TO_REMOVE+=("$pkg")
    fi
    # # TODO: possible speedup
    # if ! dpkg -l | grep -q "^ii  $pkg "; then
    #   packages_to_install+=("$pkg")
    #   DEPS_PACKAGES_TO_REMOVE+=("$pkg")
    # fi
  done

  print_notes "   üì• Packages to install: [$(echo "${packages_to_install[*]}" | tr '\n' ' ')]"
  print_notes "   üì• Packages to remove afterward: [$(echo "${DEPS_PACKAGES_TO_REMOVE[*]}" | tr '\n' ' ')]"

  # Only run sudo update and install if any package is missing.
  if [[ ${#packages_to_install[@]} -gt 0 ]]; then
    $RUN_WITH_SUDO apt-get update -qqq || {
      print_error "‚ùå Failed to update package list"
      exit 1
    }
    $RUN_WITH_SUDO apt-get install -y "${packages_to_install[@]}" 1>/dev/null || {
      print_error "‚ùå Failed to install packages"
      exit 1
    }
    [[ $IS_SUDO_INSTALL -eq 1 ]] && sudo -k
    print_notes "   üì• Build dependencies installed"
  else
    print_notes "   üì• All dependencies already installed. Skipping dependencies installation."
  fi
}

install_dependencies_needs_rm() {
  if [[ ${#DEPS_PACKAGES_TO_REMOVE[@]} -eq 0 ]]; then
    print_notes "   üì• No packages to remove."
    return 0
  fi

  print_notes "   üì• Removing build dependencies: [$(echo "${DEPS_PACKAGES_TO_REMOVE[*]}" | tr '\n' ' ')]..."
  $RUN_WITH_SUDO apt-get remove -y "${DEPS_PACKAGES_TO_REMOVE[@]}" 1>/dev/null || {
    print_error "‚ùå Failed to remove packages"
    return 1
  }
  $RUN_WITH_SUDO apt-get -y autoremove -qqq 1>/dev/null
  $RUN_WITH_SUDO apt-get -y autoclean -qqq 1>/dev/null

  [[ $IS_SUDO_INSTALL -eq 1 ]] && sudo -k
  print_notes "   üì• Packages removed: [$(echo "${DEPS_PACKAGES_TO_REMOVE[*]}" | tr '\n' ' ')]"
}

download_github_binary() {
  # "Usage: download_github_binary <repo_url> <binary_regex> [output_dir]"
  local repo_url="$1"
  local binary_regex="$2"
  local out_dir="${3:-$USER_LOCAL_PREFIX_BIN}"

  if [[ -z "$repo_url" || -z "$binary_regex" ]]; then
    print_error "‚ùå Missing argument."
    return 1
  fi

  # Check for required tools
  for cmd in curl jq; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      print_error "‚ùå Required command '$cmd' not found."
      return 1
    fi
  done

  # Extract owner/repo from URL
  local repo_path
  if [[ "$repo_url" =~ ^https://github\.com/([^/]+)/([^/]+)(\.git)?/?$ ]]; then
    local owner="${BASH_REMATCH[1]}"
    local repo="${BASH_REMATCH[2]}"
    repo_path="${owner}/${repo}"
  else
    print_error "‚ùå Could not parse GitHub repository path from URL."
    return 1
  fi

  print_info2 "\nüöÄ BINARY :: Fetching latest release for '$repo_path'..."

  # Get the asset URL matching regex
  local api_url="https://api.github.com/repos/$repo_path/releases/latest"
  echo "$api_url"
  local asset_url
  asset_url=$(curl -s "$api_url" | jq -r --arg regex "$binary_regex" '
    .assets[] | select(.name | test($regex)) | .browser_download_url
  ' 2>/dev/null | head -n 1) || { print_error "   ‚ùå Failed to jq GitHub-api '$api_url' for asset."; return 1; }

  if [[ -z "$asset_url" || "$asset_url" == "null" ]]; then
    print_error "   ‚ùå No asset matching regex '$binary_regex' found in latest release."
    return 1
  fi

  print_info2 "   üîç Found asset '$asset_url'"

  # Create temp dir and download asset
  local tmp_dir
  tmp_dir=$(mktemp -d)
  local file_name="${asset_url##*/}"

  print_info2 "   ‚¨áÔ∏è Downloading to '$tmp_dir' dir..."
  curl -sL "$asset_url" -o "$tmp_dir/$file_name"

  mkdir -p "$out_dir"

  # Handle archive or direct binary
  local bin_path=
  if [[ "$file_name" == *.tar.gz || "$file_name" == *.tgz ]]; then
    print_info2 "   ‚öôÔ∏è Extracting 'tar.gz'..."
    tar -xzf "$tmp_dir/$file_name" -C "$tmp_dir"
  elif [[ "$file_name" == *.zip ]]; then
    print_info2 "   ‚öôÔ∏è Extracting 'zip'..."
    unzip -q "$tmp_dir/$file_name" -d "$tmp_dir"
  fi
  # Search for actual binary using `file` command
  bin_path=$(find "$tmp_dir" -type f | while read -r f; do
    if file "$f" | grep -qE 'ELF|Mach-O|PE32'; then
      echo "$f"
      break
    fi
  done)

  if [[ -z "$bin_path" ]]; then
    print_error "   ‚ùå No binary file detected in asset."
    return 1
  fi

  local bin_name
  bin_name=$(basename "$bin_path")

  print_info2 "   üìå Installing '$bin_name' to '$out_dir'..."
  mv "$bin_path" "$out_dir/$bin_name"
  chmod 744 "$out_dir/$bin_name"

  # Cleanup
  rm -rf "$tmp_dir"

  print_info2 "üöÄ BINARY :: '$repo_path : $bin_name' installed!"
}

# ******************************************************************************

# BASE :: check if new version available ---------------------------------------
check_for_newer_tag() {
  local REPO_URL="$1"
  local CURRENT_TAG="$2"
  local TAG_FILTER="${3:-}"

  # Derive owner/repo from URL
  local REPO_NAME
  REPO_NAME=$(echo "$REPO_URL" | sed -E 's|https://github\.com/||; s|\.git$||')

  # Fetch all tags via GitHub API
  local TAGS_JSON
  TAGS_JSON=$(curl -sL "https://api.github.com/repos/$REPO_NAME/tags")

  if [[ -z $TAGS_JSON || $TAGS_JSON == *"API rate limit exceeded"* ]]; then
    print_error "‚ö†Ô∏è GitHub API rate limit exceeded or no response for $REPO_NAME."
    return 0
  fi

  # Extract tag names
  local TAGS
  TAGS=$(echo "$TAGS_JSON" | jq -r '.[].name')

  # Handle tag filtering
  if [[ -n $TAG_FILTER ]]; then
    if [[ $TAG_FILTER == -* ]]; then
      # Exclude tags matching the pattern
      local EXCLUDE_FILTER="${TAG_FILTER:1}"
      TAGS=$(echo "$TAGS" | grep -Ev -- "$EXCLUDE_FILTER" || true)
    else
      # Include only matching tags
      TAGS=$(echo "$TAGS" | grep -E -- "$TAG_FILTER" || true)
    fi
  fi

  # Determine the latest tag by version-sort
  local LATEST_TAG
  LATEST_TAG=$(echo "$TAGS" | sort -V | tail -n1)

  # Fallback: no matching tags ‚Üí try latest release
  if [[ -z $LATEST_TAG || $LATEST_TAG == "null" ]]; then
    LATEST_TAG=$(curl -sL "https://api.github.com/repos/$REPO_NAME/releases/latest" |
      jq -r '.tag_name')
    # Ensure the release tag matches the filter (if it's an inclusion filter)
    if [[ -n $TAG_FILTER && $TAG_FILTER != -* && ! $LATEST_TAG =~ $TAG_FILTER ]]; then
      print_info2 "‚ö†Ô∏è No releases matching filter '$TAG_FILTER' for $REPO_NAME."
      return 0
    fi
    # If exclusion filter, skip if it matches the exclusion
    if [[ -n $TAG_FILTER && $TAG_FILTER == -* && $LATEST_TAG =~ ${TAG_FILTER:1} ]]; then
      print_info2 "‚ö†Ô∏è Latest release '$LATEST_TAG' excluded by filter '${TAG_FILTER}'."
      return 0
    fi
  fi

  # Final validation
  if [[ -z $LATEST_TAG || $LATEST_TAG == "null" ]]; then
    print_error "‚ö†Ô∏è No tags or releases found for $REPO_NAME."
    return 0
  fi

  # Compare and report
  if [[ $CURRENT_TAG != "$LATEST_TAG" ]]; then
    print_info2 "‚¨ÜÔ∏è A newer version for '$REPO_NAME' is available: $LATEST_TAG (current: $CURRENT_TAG)"
    print_info2 "    https://github.com/$REPO_NAME/releases/tag/$LATEST_TAG"
  else
    print_info2 "‚úÖ You already have the latest version for '$REPO_NAME': $CURRENT_TAG"
  fi
}
