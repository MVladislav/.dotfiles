#!/usr/bin/env bash
set -euo pipefail
IFS=$' '

# -------- Configuration ----------
# OUT_FILE="release.md"
DEFAULT_REMOTE=${DEFAULT_REMOTE:-origin}
DEFAULT_BRANCH=${DEFAULT_BRANCH:-main}
# DEFAULT_BRANCH=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's|^origin/||')
# Group labels and order
declare -A GROUP_LABEL=(
  [feat]="‚ú® Features"
  [fix]="üêõ Fixes"
  [docs]="üìù Documentation"
  [refactor]="‚ôªÔ∏è Refactoring"
  [perf]="‚ö° Performance"
  [test]="‚úÖ Tests"
  [chore]="üîß Chores"
  [security]="üîí Security"
  [init]="üì¶ Init"
  [release]="üè∑Ô∏è Release"
  [other]="üì¶ Other"
)
ORDER=(feat fix docs refactor perf test chore security release init other)

# -------- Utilities ----------
err() {
  printf 'ERROR: %s\n' "$*" >&2
  exit 1
}
info() { printf '%s\n' "$*"; }

require_git() {
  git rev-parse --is-inside-work-tree &>/dev/null || err "Not a Git repo"
}

get_remote_repo_slug() {
  local remote_url slug
  remote_url=$(git remote get-url origin 2>/dev/null) || return 1
  remote_url="${remote_url%.git}" # remove .git
  case "$remote_url" in
  git@*:*/*)
    slug="${remote_url#*:}" # strip "git@github.com:"
    ;;
  https://* | http://* | ssh://*)
    slug="${remote_url#*github.com/}" # strip URL prefix
    ;;
  *)
    echo "unknown/unknown"
    return 1
    ;;
  esac
  echo "$slug"
}

list_refs_combined() {
  # heads then tags by recent committer/creatordate
  git for-each-ref --format='%(refname:short)|%(committerdate:unix)' refs/heads refs/remotes |
    awk -F'|' '{print $1 " " $2}' |
    sort -k2 -nr |
    awk '{print $1}' | uniq
  git tag --sort=-creatordate
}

pick_ref_interactive() {
  local prompt="$1" default="${2:-}"
  if command -v fzf >/dev/null; then
    list_refs_combined | sort -hr | fzf --prompt="$prompt" --query="$default"
  else
    err "Interactive selection requires fzf and USE_FZF=1"
  fi
}

require_git

# interactive
BASE_REF=$(pick_ref_interactive "Select BASE: ")
[[ -n "$BASE_REF" ]] || err "No base selected"
COMPARE_REF=$(pick_ref_interactive "Select COMPARE: " "$DEFAULT_REMOTE/$DEFAULT_BRANCH")
[[ -n "$COMPARE_REF" ]] || err "No compare selected"

# Normalize short names for display
version_base=$(basename "$BASE_REF")
version_compare=$(basename "$COMPARE_REF")
info "üîç Comparing: ${version_base} ‚Üê ${version_compare}"
info

# Get remote slug (owner/repo) for links
REMOTE_SLUG=$(get_remote_repo_slug)
# Build compare URL base (if possible)
if [[ -n "$REMOTE_SLUG" ]]; then
  COMPARE_URL_BASE="https://github.com/${REMOTE_SLUG}/compare"
else
  COMPARE_URL_BASE=""
fi

# Git log (exclude merges). Use full hash for linkability.
mapfile -t RAW_LOG < <(git log --no-merges --pretty=format:"%s|%H|%h|%an|%ae" --reverse --left-right "$BASE_REF".."$COMPARE_REF")

if [[ ${#RAW_LOG[@]} -eq 0 ]]; then
  info "‚úÖ No new commits between ${BASE_REF} and ${COMPARE_REF}."
  exit 0
fi

# Helper: extract PR
extract_pr() {
  local subj="$1"
  if [[ "$subj" =~ \(\#([0-9]+)\) ]]; then
    printf "%s" "${BASH_REMATCH[1]}"
    return
  fi
  if [[ "$subj" =~ PR[[:space:]]\#([0-9]+) ]]; then
    printf "%s" "${BASH_REMATCH[1]}"
    return
  fi
  if [[ "$subj" =~ \#([0-9]+) ]]; then
    printf "%s" "${BASH_REMATCH[1]}"
    return
  fi
  printf ""
}

# Initialize buckets
declare -A BUCKETS
declare -A SUBBUCKETS # key: type:scope -> multiline string
for k in "${!GROUP_LABEL[@]}"; do BUCKETS["$k"]=""; done

# Parse commits
for entry in "${RAW_LOG[@]}"; do
  IFS='|' read -r subject full_hash short_hash author_name author_email <<<"$entry"
  subject="${subject#"${subject%%[![:space:]]*}"}"
  subject="${subject%"${subject##*[![:space:]]}"}"

  # conventional commit parse: type(scope)?: message
  if [[ "$subject" =~ ^([a-zA-Z0-9]+)(\(.+\))?:[[:space:]]*(.+)$ ]]; then
    type="${BASH_REMATCH[1],,}"
    scope="${BASH_REMATCH[2]:-}"
    [[ -n "$scope" ]] && scope="${scope:1:-1}" || scope=""
    msg="${BASH_REMATCH[3]}"
  else
    type="other"
    scope=""
    msg="$subject"
  fi

  # Normalize type to known or other
  [[ -z "${GROUP_LABEL[$type]:-}" ]] && type="other"

  # Extract PR
  prnum=$(extract_pr "$subject")
  pr_part=""
  if [[ -n "$prnum" && "$prnum" != "0" ]]; then
    if [[ -n "$REMOTE_SLUG" ]]; then
      pr_part=" ([#${prnum}](https://github.com/${REMOTE_SLUG}/pull/${prnum}))"
    else
      pr_part=" (#${prnum})"
    fi
  fi

  # Commit link
  commit_link=""
  if [[ -n "$REMOTE_SLUG" ]]; then
    commit_link=" ([\`${short_hash}\`](https://github.com/${REMOTE_SLUG}/commit/${full_hash}))"
  else
    commit_link=" (\`${short_hash}\`)"
  fi

  author_display="by @${author_name} <${author_email}>"
  line="- ${msg}${commit_link}${pr_part} - ${author_display}"

  # Handle PR #0 as default scope
  [[ "$scope" == "#0" ]] && scope="default"

  # Bucket commits
  if [[ -n "$scope" ]]; then
    subkey="${type}:${scope,,}"
    SUBBUCKETS["$subkey"]+="$line"$'\n'
  else
    BUCKETS["$type"]+="$line"$'\n'
  fi
done

# Render markdown into variable
today=$(date +"%Y-%m-%d")
out=""
out+="# üöÄ Release \`${version_base}..${version_compare}\` - ${today}"$'\n\n'
# out+="### Highlights:"$'\n\n'
# out+="  - **Example**"$'\n'
# out+=$'\n\n''---'$'\n\n'
out+="## What's Changed"$'\n\n'

for t in "${ORDER[@]}"; do
  content="${BUCKETS[$t]:-}"
  # collect subkeys for type t
  subkeys=()
  for k in "${!SUBBUCKETS[@]}"; do
    if [[ "$k" == "${t}:"* ]]; then subkeys+=("$k"); fi
  done

  if [[ -z "$content" && ${#subkeys[@]} -eq 0 ]]; then continue; fi
  out+="### ${GROUP_LABEL[$t]}"$'\n\n'
  if [[ -n "$content" ]]; then out+="${content}"$'\n'; fi

  # Print sub-scopes
  if [[ ${#subkeys[@]} -gt 0 ]]; then
    mapfile -t sorted < <(printf "%s\n" "${subkeys[@]}" | sort)
    for sk in "${sorted[@]}"; do
      scope_name="${sk#"${t}":}"
      out+="#### ${scope_name}"$'\n\n'
      out+="${SUBBUCKETS[$sk]}"$'\n'
    done
  fi
done

# Full changelog link
if [[ -n "$COMPARE_URL_BASE" ]]; then
  out+="**Full Changelog**: ${COMPARE_URL_BASE}/${version_base}...${version_compare}"$'\n'
else
  # attempt remote slug fallback
  remote_origin=$(git remote get-url "$DEFAULT_REMOTE" 2>/dev/null || true)
  if [[ -n "$remote_origin" ]]; then
    out+="**Full Changelog (remote)**: ${remote_origin} compare ${version_base}...${version_compare}"$'\n'
  else
    out+="**Full Changelog**: compare ${version_base}...${version_compare}"$'\n'
  fi
fi

out+=$'\n\n''---'$'\n\n'
out+='## Notes'$'\n\n'
out+="- Create release branch: \`git checkout -b release/x.x.x\`."$'\n'
out+="- Update \`pyproject.toml\` version number."$'\n'
out+="- Update **uv.lock** run: \`uv sync --all-groups\`."$'\n'
out+="- Release commit: \`chore(release): bump version x.x.x\`."$'\n'
out+="- Create **pull request** and merge/rebase into main\`."$'\n'
out+="- Release tag: \`git tag -a vx.x.x -m 'Release version x.x.x'\`."$'\n'

# Output
if [[ -n "${OUT_FILE:-}" ]]; then
  printf '%s\n' "$out" >"$OUT_FILE"
  info "Wrote release notes to $OUT_FILE"
else
  printf '%s\n' "$out"
fi
