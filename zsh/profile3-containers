#!/usr/bin/env bash
### DOCKER ###
alias docker='DOCKER_BUILDKIT=1 docker'
alias docker-compose='docker compose'
docker-swarm-compose() {
  local COMPOSE_FILES=()
  local RESOLVE_IMAGE="never"
  local ARGS=()

  # 1) Parse flags and collect everything else into ARGS
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--file)
        if [[ -n "${2:-}" && -f "$2" ]]; then
          COMPOSE_FILES+=("$2")
          shift 2
        else
          echo "Error: Missing or invalid file after $1" >&2
          return 1
        fi
        ;;
      never|always)
        RESOLVE_IMAGE="$1"
        shift
        ;;
      *)
        ARGS+=("$1")
        shift
        ;;
    esac
  done

  # 2) Default compose file if none provided
  if [[ "${#COMPOSE_FILES[@]}" -eq 0 ]]; then
    COMPOSE_FILES=(docker-compose.yaml)
  fi

  # 3) Ensure we have at least a stack name
  if [[ "${#ARGS[@]}" -lt 1 ]]; then
    echo "Usage: docker-swarm-compose [-f <file> ...] [never|always] <STACK_NAME> [extra args...]" >&2
    return 1
  fi

  # 4) Re-assign positional params to whatâ€™s in ARGS
  set -- "${ARGS[@]}"

  # 5) Extract stack name & extra args
  local STACK_NAME="$1"
  shift
  local EXTRA_ARGS=( "$@" )

  echo "Deploying stack '$STACK_NAME' with files: ${COMPOSE_FILES[*]} :: [resolve=$RESOLVE_IMAGE]"

  # 6) Build the '-f file' args for docker compose
  local FILE_ARGS=()
  for f in "${COMPOSE_FILES[@]}"; do
    FILE_ARGS+=(-f "$f")
  done

  # 7) Pipe the final config into docker stack deploy
  docker compose "${FILE_ARGS[@]}" --compatibility config \
    | sed 's|cpus: \([0-9]\+\(\.[0-9]\+\)*\)|cpus: "\1"|' \
    | sed '1{/^name:/d}' \
    | sed 's/published: "\(.*\)"/published: \1/' \
    | sed 's|mode: "\([0-9]\+\)"|mode: \1|' \
    | docker stack deploy \
        --resolve-image="$RESOLVE_IMAGE" \
        --with-registry-auth \
        --detach=false \
        --compose-file - \
        "$STACK_NAME" \
        "${EXTRA_ARGS[@]}"
}

docker-context() {
  if [ "$#" -lt 2 ]; then
    echo "Usage: $0 <CONTEXT-NAME> <SSH-HOST>"
    return 1
  fi
  docker context create "$1" --docker "host=ssh://$2"
}

# shellcheck disable=SC2139
alias vm_quick_docker_ubuntu="mkdir -p ${HOME}/docker/$(date +'%Y-%m-%d') && docker run -it --rm --network host --user root -v ${HOME}/docker/$(date +'%Y-%m-%d'):/tmp/docker --name=ubuntu-server ubuntu:24.04"

### KUBERNETES ###
alias h='helm'
alias k='kubectl'
alias kn='k config set-context --current --namespace'
alias ka='kubectl apply -f'
alias kg='kubectl get'
alias kd='kubectl describe'
alias kdel='kubectl delete'
alias kl='kubectl logs -f'
alias kgpo='kubectl get pod'
alias kgd='kubectl get deployments'
alias kc='kubectx'
alias kns='kubens'
alias ke='kubectl exec -it'
alias kcns='kubectl config set-context --current --namespace'

### TERRAFORM ###
alias tf='terraform'

######################################################################
##
## OpenShift: (oc) Helper Functions
##
######################################################################

# Alias to quickly view the current project
alias ocp='oc project'

# Switch projects interactively using fzf
vm_oc_switch() {
  local project
  project=$(oc projects -q | fzf --prompt="Select project: ")
  if [ -z "$project" ]; then
    echo "No project selected."
    return 1
  fi
  oc project "$project"
}

# Follow logs for a selected pod (interactive selection via fzf)
vm_oc_logs() {
  local pod
  pod=$(oc get pods --no-headers 2>/dev/null | fzf --prompt="Select pod for logs: " | awk '{print $1}')
  if [ -z "$pod" ]; then
    echo "No pod selected."
    return 1
  fi
  oc logs -f "$pod"
}

vm_oc_logs_search() {
  local pod container containers

  # Select a pod using fzf
  pod=$(oc get pods --no-headers 2>/dev/null | fzf --prompt="Select pod for logs: " | awk '{print $1}')
  if [ -z "$pod" ]; then
    echo "No pod selected."
    return 1
  fi

  # Check if the selected pod has multiple containers and prompt for one if so.
  containers=$(oc get pod "$pod" -o jsonpath='{.spec.containers[*].name}' 2>/dev/null)
  if [ "$(echo "$containers" | wc -w)" -gt 1 ]; then
    container=$(echo "$containers" | tr ' ' '\n' | fzf --prompt="Select container: ")
  fi

  echo "Streaming logs for pod '$pod'${container:+ (container: $container)}. Press Ctrl-C to exit."

  # Tail the logs and pipe them to fzf for interactive searching.
  if [ -n "$container" ]; then
    oc logs -f "$pod" -c "$container" 2>&1 | fzf --ansi --cycle
  else
    oc logs -f "$pod" 2>&1 | fzf --ansi --cycle
  fi
}

# Open an interactive shell in a selected pod's container
vm_oc_shell() {
  local pod container containers
  pod=$(oc get pods --no-headers 2>/dev/null | fzf --prompt="Select pod for shell: " | awk '{print $1}')
  if [ -z "$pod" ]; then
    echo "No pod selected."
    return 1
  fi

  # Retrieve container names for the pod
  containers=$(oc get pod "$pod" -o jsonpath='{.spec.containers[*].name}')
  if [[ $(echo "$containers" | wc -w) -gt 1 ]]; then
    container=$(echo "$containers" | tr ' ' '\n' | fzf --prompt="Select container: ")
  fi

  # Try bash first, fallback to sh if bash is unavailable
  if [ -n "$container" ]; then
    oc exec -it "$pod" -c "$container" -- bash 2>/dev/null || oc exec -it "$pod" -c "$container" -- sh
  else
    oc exec -it "$pod" -- bash 2>/dev/null || oc exec -it "$pod" -- sh
  fi
}

# Describe a resource interactively.
vm_oc_describe() {
  local resource_type resource

  # List of common resource types. Extend this list as needed.
  local resource_types=("pods" "svc" "deployment" "dc" "route" "configmap" "secret" "pvc" "buildconfig")

  resource_type=$(printf "%s\n" "${resource_types[@]}" | fzf --prompt="Select resource type: ")
  if [ -z "$resource_type" ]; then
    echo "No resource type selected."
    return 1
  fi

  resource=$(oc get "$resource_type" --no-headers 2>/dev/null | fzf --prompt="Select $resource_type: " | awk '{print $1}')
  if [ -z "$resource" ]; then
    echo "No $resource_type selected."
    return 1
  fi

  oc describe "$resource_type" "$resource"
}

# Additional example: Follow logs for a deployment config (dc)
vm_oc_dc_logs() {
  local dc
  dc=$(oc get dc --no-headers 2>/dev/null | fzf --prompt="Select deployment config: " | awk '{print $1}')
  if [ -z "$dc" ]; then
    echo "No deployment config selected."
    return 1
  fi
  oc logs -f dc/"$dc"
}

######################################################################
##
## quick ubuntu: create and remove multipass ubuntu VM
##
######################################################################
vm_quick_ubuntu() {
  if [[ -z "$1" ]]; then
    echo "Usage: $0 <VM_NAME_VERSION> [<optional post-creation command>]"
    return 1
  fi

  TMP_CLOUD_INIT=~/vm_quick_ubuntu_cloud_init.yaml
  {
    echo '#cloud-config'
    echo 'packages_update: true'
    echo 'packages_upgrade: true'
    echo 'packages:'
    echo '  - cowsay'
    echo '  - neofetch'
    echo 'ssh_authorized_keys:'
    echo '  - ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJOBsi+JPb9GLFKA83kRpaphBrvb2uM9r0U0S+SPx1Mo ansible-admin'
  } >"$TMP_CLOUD_INIT"

  # Clean up VM name by removing dots and replacing colons with hyphens
  VM_NAME_VERSION=$(echo "$1" | sed 's|\.||g' | tr ':' '-')

  # Launch the VM with multipass
  multipass launch "$1" -n "ubuntu-$VM_NAME_VERSION" -c 2 -d 16G -m 4G --cloud-init "$TMP_CLOUD_INIT" || {
    echo "Failed to launch VM."
    rm "$TMP_CLOUD_INIT"
    return 1
  }

  # Remove cloud-init file after VM creation
  rm "$TMP_CLOUD_INIT"

  # Run an optional post-creation command, default to 'neofetch' if not provided
  multipass exec "ubuntu-$VM_NAME_VERSION" -- sh -c "${2:-neofetch}"
}

vm_quick_ubuntu_rm() {
  if [[ -z "$1" ]]; then
    echo "Usage: $0 <VM_NAME_VERSION>"
    return 1
  fi

  # Clean up VM name
  VM_NAME_VERSION=$(echo "$1" | sed 's|\.||g' | tr ':' '-')

  # Stop, delete, and purge the VM
  multipass stop "ubuntu-$VM_NAME_VERSION" || {
    echo "Failed to stop VM."
    return 1
  }
  multipass delete "ubuntu-$VM_NAME_VERSION" || {
    echo "Failed to delete VM."
    return 1
  }
  multipass purge || {
    echo "Failed to purge VM resources."
    return 1
  }

  # Show current list of VMs
  multipass list
}
