#!/usr/bin/env bash

### COLOR ### (https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux)
NC='\033[0m'         # No Color
BRED='\033[1;31m'    # Red
BPURPLE='\033[1;35m' # Purple

### PY & ANSIBLE ###
export PY_COLOR=1
export ANSIBLE_FORCE_COLOR=1

### ZSH ###
if command -v zsh &>/dev/null; then
  setopt NO_NOMATCH
fi

### BASH ###
export HISTTIMEFORMAT="%F %T "
alias sudo-env='sudo -E env "PATH=$PATH"'

### EDITOR ###
if command -v nvim &>/dev/null; then
  export EDITOR='nvim'
  export SUDO_EDITOR="nvim"
else
  export EDITOR='vim'
  export SUDO_EDITOR="vim"
fi

######################################################################
##
## set PATH so it includes user's private bin if it exists
##
######################################################################
if [ -d "$HOME/.local/bin" ]; then
  if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    export PATH="$HOME/.local/bin:$PATH"
  fi
fi

if [ -d /etc/zsh/profile.d ]; then
  if ls /etc/zsh/profile.d/*.sh 1>/dev/null 2>&1; then
    for i in /etc/zsh/profile.d/*.sh; do
      if [ -r "$i" ]; then
        # shellcheck disable=SC1090
        . "$i"
      fi
    done
    unset i
  fi
fi

######################################################################
##
## set PATH for dev env
##
######################################################################
export GOPATH="$HOME/.go"
if [[ ":$PATH:" != *":/usr/local/go/bin:"* ]]; then
  export PATH="$PATH:/usr/local/go/bin"
fi
if [[ ":$PATH:" != *":$GOPATH/bin:"* ]]; then
  export PATH="$PATH:$GOPATH/bin"
fi

NPM_PACKAGES="${HOME}/.npm-packages"
if [[ ":$PATH:" != *":$NPM_PACKAGES/share/man:"* ]]; then
  export MANPATH="${MANPATH-$(manpath)}:$NPM_PACKAGES/share/man"
fi
if [[ ":$PATH:" != *":/snap/node/current/bin:"* ]]; then
  export PATH="/snap/node/current/bin:$PATH"
fi
if [[ ":$PATH:" != *":$NPM_PACKAGES/bin:"* ]]; then
  export PATH="$PATH:$NPM_PACKAGES/bin"
fi

export GEM_HOME="$HOME/.gems"
if [[ ":$PATH:" != *":$GEM_HOME/bin:"* ]]; then
  export PATH="$PATH:$GEM_HOME/bin"
fi

### LS as EZA ###
if command -v eza &>/dev/null; then
  alias ls='eza --color=always --git'
fi
alias l='ls -a1'
alias ll='ls -aalhg'
alias lg='ll --grid'
alias llm='ll -t modified -s modified'
alias lla='ll -t accessed -s accessed'
alias llc='ll -t created -s created'
alias ld='ls -ld .*'
alias tree='ls -TlL 4'

### CAT as BAT ###
alias catt='batcat -p -P --color always'
alias catt-b='batcat -P --color always'

### CP as RSYNC ###
alias cp-r='rsync --info=progress2 --stats -auz'
alias scp-r='rsync --info=progress2 -auz -e "ssh -T -o Compression=no -x"'
alias scp-ra='rsync --info=progress2 -az -e "ssh -T -o Compression=no -x"'

### FIND ###
alias find-no='sudo /usr/bin/find / -nouser -o -nogroup -ls 2>/dev/null'
find-g() {
  sudo /usr/bin/find / \
    -not -regex '/home/.*' \
    -not -regex '/mnt/.*' \
    -not -regex '/media/.*' \
    -not -regex '.*/\.cache/.*' \
    -not -regex '/proc/.*' \
    -not -regex '/sys/.*' \
    -not -regex '/var/log/.*' \
    -newermt "-${1:-5} minute" -ls 2>/dev/null
}
find-l() {
  /usr/bin/find "${2:-.}" \
    -not -regex "${3:-x}" \
    -newermt "-${1:-5} minute" -ls 2>/dev/null
}

### DOCKER ###
alias docker='DOCKER_BUILDKIT=1 docker'
alias docker-compose='docker compose'
alias docker-swarm-compose='docker compose --compatibility config | sed '\''s|cpus: \([0-9]\+\(\.[0-9]\+\)*\)|cpus: "\1"|'\'' | sed '\''1{/^name:/d}'\'' | sed '\''s/published: "\(.*\)"/published: \1/'\'' | docker stack deploy --resolve-image=never --with-registry-auth --detach=false --compose-file -'
alias docker-swarm='docker compose --compatibility config | sed '\''s|cpus: \([0-9]\+\(\.[0-9]\+\)*\)|cpus: "\1"|'\'' | sed '\''1{/^name:/d}'\'' | sed '\''s/published: "\(.*\)"/published: \1/'\'' | docker stack deploy --resolve-image=always --with-registry-auth --detach=false --compose-file -'
docker-context() {
  if [ "$#" -lt 2 ]; then
    echo "Usage: docker-context <CONTEXT-NAME> <SSH-HOST>"
    return 1
  fi
  docker context create "$1" --docker "host=ssh://$2"
}

# shellcheck disable=SC2139
alias vm_quick_docker_ubuntu="mkdir -p ${HOME}/docker/$(date +'%Y-%m-%d') && docker run -it --rm --network host --user root -v ${HOME}/docker/$(date +'%Y-%m-%d'):/tmp/docker --name=ubuntu-server ubuntu:24.04"
alias vm_quick_docker_iperf="docker run -d -it --rm --name=iperf3-server -p 5201:5201 networkstatic/iperf3 -s"

### KUBERNETES ###
alias h='helm'
alias k='kubectl'
alias kn='k config set-context --current --namespace'
alias ka='kubectl apply -f'
alias kg='kubectl get'
alias kd='kubectl describe'
alias kdel='kubectl delete'
alias kl='kubectl logs'
alias kgpo='kubectl get pod'
alias kgd='kubectl get deployments'
alias kc='kubectx'
alias kns='kubens'
alias kl='kubectl logs -f'
alias ke='kubectl exec -it'
alias kcns='kubectl config set-context --current --namespace'

### TERRAFORM ###
alias tf='terraform'

### ZED ###
if command -v flatpak &>/dev/null; then
  alias zed-editor='flatpak run dev.zed.Zed'
fi

### PYTHON TOOLS ###
alias vm_url_decode='python3 -c "import sys, urllib.parse as ul; print(ul.unquote_plus(sys.argv[1]))"'
alias vm_url_encode='python3 -c "import sys, urllib.parse as ul; print(ul.quote_plus(sys.argv[1]))"'
alias vm_reverse='python3 -c "import sys; print(sys.argv[1][::-1])"'

alias vm_hun_to_min="python3 -c 'import sys;x = sys.argv[1].split(\":\");x3 = (int(x[0]) * 60) + ((int(x[1])/100)*60);print(x3, \":: \", f\"{divmod(x3, 60)[0]}h : {divmod(x3, 60)[1]}m\")'"

# $sudo apt install xclip
# $pip3 install pyperclip
alias vm_copy_from_clip='python3 -c "import sys, pyperclip; pyperclip.copy(sys.argv[1])"'

### GIT ###
alias vm_git_log1="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"
alias vm_git_log2="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"

alias vm_git_pre='pre-commit run --files $(git ls-files | tr "\n" " ")'
alias vm_git_diff='git difftool --tool=nvimdiff'
alias vm_git_rei='git rm -r --cached . && git add . && git commit -m "refactor: reapply .gitignore rules"'

### TMUX ###
alias vm_tl='tmux ls'
alias vm_ta='tmux attach -t'
alias vm_tk='tmux kill-session -t'

### VIM ###
if command -v nvim &>/dev/null; then
  alias vim=nvim
fi

### updater ###
alias vm_up_apt='sudo /usr/bin/apt update && sudo /usr/bin/apt upgrade'
alias vm_up_snap='sudo /usr/bin/snap refresh'
alias vm_up_flatpak='/usr/bin/flatpak update && /usr/bin/flatpak uninstall --unused'
alias vm_up_py_pip='python3 -m pip list --user -o | cut -f1 -d" " | tr " " "\n" | awk "{if(NR>=3)print}" | cut -d" " -f1 | xargs -n1 python3 -m pip install --user --no-cache-dir -U --break-system-packages'
alias vm_up_py_pip_root='sudo /usr/bin/python3 -m pip list -o | cut -f1 -d" " | tr " " "\n" | awk "{if(NR>=3)print}" | cut -d" " -f1 | sudo /usr/bin/xargs -n1 python3 -m pip install --no-cache-dir -U --break-system-packages'
vm_update_clean_all() {
  print_separator() {
    echo -e '\n#########################################################################\n'
  }

  # Update and clean apt
  echo "${BPURPLE}Updating apt...${NC}"
  if sudo apt update && sudo apt full-upgrade -y; then
    echo "${BPURPLE}Apt update and upgrade completed.${NC}"
  else
    echo "${BRED}Apt update or upgrade failed.${NC}" >&2
  fi

  echo "${BPURPLE}Cleaning apt...${NC}"
  if sudo apt autoclean -y && sudo apt autoremove -y && sudo apt clean; then
    echo "${BPURPLE}Apt cleanup completed.${NC}"
  else
    echo "${BRED}Apt cleanup failed.${NC}" >&2
  fi

  print_separator

  # Update and clean snap
  echo "${BPURPLE}Updating snap...${NC}"
  if sudo snap refresh; then
    echo "${BPURPLE}Snap update completed.${NC}"
  else
    echo "${BRED}Snap update failed.${NC}" >&2
  fi

  echo "${BPURPLE}Cleaning snap...${NC}"
  if LANG=en_US.UTF-8 sudo snap list --all | awk '/disabled/ {print $1, $3}' | while read -r SNAPNAME REVISION; do
    sudo snap remove "$SNAPNAME" --revision="$REVISION"
  done; then
    echo "${BPURPLE}Snap cleanup completed.${NC}"
  else
    echo "${BRED}Snap cleanup failed.${NC}" >&2
  fi

  print_separator

  # Update and clean flatpak
  echo "${BPURPLE}Updating flatpak...${NC}"
  if sudo flatpak update; then
    echo "${BPURPLE}Flatpak update completed.${NC}"
  else
    echo "${BRED}Flatpak update failed.${NC}" >&2
  fi

  echo "${BPURPLE}Cleaning flatpak...${NC}"
  if sudo flatpak uninstall --unused && sudo rm -rfv /var/tmp/flatpak-cache-*; then
    echo "${BPURPLE}Flatpak cleanup completed.${NC}"
  else
    echo "${BRED}Flatpak cleanup failed.${NC}" >&2
  fi

  print_separator

  # Additional updates for Python pip
  echo "You could also run more additional updates:"
  echo "  - run ${BPURPLE}'vm_up_py_pip'${NC} to update Python pip installs by user."
  echo "  - run ${BRED}'vm_up_py_pip_root'${NC} to update Python pip installs by root (be cautious, could potentially break things)."
}

### OTHER ###
alias grep='grep --color'
alias sgrep='grep -R -n -H -C 5 --exclude-dir={.git,.svn,CVS}'

alias pigz='pigz -k -p$(nproc)'
tar-p() {
  if [ "$#" -lt 1 ]; then
    echo "Usage: tar-p <directory> [<password>]"
    return 1
  fi

  PATH_TO_ENC="$1"
  if [ $# -eq 1 ]; then
    tar --use-compress-program="pigz " -cpf "$(basename "$PATH_TO_ENC").tar.gz" -C "$PATH_TO_ENC" .
  elif [ $# -eq 2 ]; then
    PASSWORD_FOR_ENC="$2"
    tar --use-compress-program="pigz " -cpf - -C "$PATH_TO_ENC" . | gpg -c --cipher-algo AES256 --batch --passphrase "$PASSWORD_FOR_ENC" -o "$(basename "$PATH_TO_ENC").tar.gz.gpg.enc"
  fi
}

untar-p() {
  if [ "$#" -lt 2 ]; then
    echo "Usage: untar-p <encrypted_file> <password>"
    return 1
  fi

  mkdir -p "$(dirname "$1")/${1%%.*}"
  gpg -d --batch --passphrase "$2" "$1" | tar --use-compress-program="pigz " -xpf - -C "$(dirname "$1")/${1%%.*}"
}

alias vm_mem_free='free -h && sudo /usr/bin/sysctl -w vm.drop_caches=3 && sudo /usr/bin/sync && echo 3 | sudo /usr/bin/tee /proc/sys/vm/drop_caches && free -h'

alias t='tail -f'
alias du-l='du -hs * .* 2>/dev/null | sort -h'
alias du-g='du -hs /boot /dev /etc /home /opt /root /snap /srv /sys /tmp /usr /var 2>/dev/null | sort -h'
alias ip='ip -c'

alias chmod_ux="chmod u+x"
alias vm_ux_term="tr -d '\r' <"

alias vm_random='openssl rand -base64'
vm_random2() {
  tr -dc A-Za-z0-9 </dev/urandom | head -c "$1"
  echo ''
}
alias vm_find_command='apropos'

: "${VM_ANDROID_PATH=$HOME/Android}"
vm_quick_android_emulator() {
  selected_emulator=$("${VM_ANDROID_PATH}/Sdk/emulator/emulator" -list-avds | grep -v INFO | fzf)
  if [[ -z $selected_emulator ]]; then
    return 1
  fi
  "${VM_ANDROID_PATH}/Sdk/emulator/emulator" -cores 4 -memory 4096 -no-boot-anim -writable-system -gpu host -avd "$selected_emulator"
}

### TOOLS ###
alias vm_weather='curl https://wttr.in/${VM_WEATHER_LOCATION:-Stuttgart},${VM_WEATHER_COUNTRY:-de}'
alias vm_speed='curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python3 - --secure'
alias vm_speed_local='clear && iperf3 -p 5201 -Tl1 -4 -b0 -i3 -O1 -P1 -w128m -t0 -c'
# https://github.com/R0GGER/public-iperf3-servers | https://iperf.fr/iperf-servers.php
vm_speed_pub() {
  if [ "$#" -lt 1 ]; then
    echo "Usage: $0 <NUM> [ADDITIONAL_IPERF3_PARAMS... (-w128M | -R | -t0)]"
    return 1
  fi

  local servers=(
    "a209.speedtest.wobcom.de:5201" # 1
    "a205.speedtest.wobcom.de:5201" # 2
    "speedtest.lu.buyvm.net:5201"   # 3
    "iperf3.moji.fr:5201"           # 4
    "ping.online.net:5001"          # 5 change
    "speedtest.init7.net:5201"      # 6
    "speedtest.shinternet.ch:5200"  # 7
    "speedtest.serverius.net:5002"  # 8 change
  )

  local num="$1"
  shift
  if ! [[ "$num" =~ ^[0-9]+$ ]] || [ "$num" -lt 1 ] || [ "$num" -gt "${#servers[@]}" ]; then
    num=1
  fi

  local entry="${servers[$((num))]}"
  local server="${entry%%:*}" # Extract server name (before :)
  local port="${entry##*:}"   # Extract port number (after :)

  clear
  iperf3 -c "$server" -p "$port" -Ts1 -b0 -i3 -O1 -P1 "$@"
}

######################################################################
##
## markdown to csv: converts a markdown table to csv
##
######################################################################
vm_markdown_to_csv() {
  if [ "$#" -lt 1 ]; then
    echo "Usage: $0 <MARKDOWN_FILE>"
    return 1
  fi

  sed '2d' "$1" | sed '2d' | sed -e 's/^| //' -e 's/ |$//' -e 's/ | /,/g' |
    awk -F, '{
      for (i=1; i<=NF; i++) {
        gsub(/^ *| *$/, "", $i);  # Remove leading and trailing spaces
        if (i > 1) printf ",";
          #$i = "\"" $i "\"";     # Sourund with double quote
          printf "%s", $i;
        }
        printf "\n";
      }' >"$(basename "$1" | cut -d. -f1).csv"
}

######################################################################
##
## ii: display useful host related information
##
######################################################################
alias vm_my_ip='curl -s ifconfig.io/ip'
alias vm_my_host='curl -s ifconfig.io/host'
alias vm_my_country='curl -s ifconfig.io/country_code'
alias vm_my_ua='curl -s ifconfig.io/ua'
alias vm_my_all='curl -s ifconfig.io/all.json | jq'
vm_my_bios() {
  for d in bios-vendor bios-version bios-release-date bios-revision system-manufacturer system-product-name system-version system-family baseboard-manufacturer baseboard-product-name baseboard-version processor-family processor-manufacturer processor-version processor-frequency; do
    printf "  - %-25s: %s\n" "$d" "$(sudo /usr/sbin/dmidecode -s "$d")"
  done
}

vm_ii() {
  echo -e "\\n${BRED}You are logged on:$NC $(hostname)"
  echo -e "\\n${BRED}Additional information:$NC"
  echo -e "  - description           : $(lsb_release -d | cut -d':' -f2- | xargs)"
  echo -e "  - kernel name           : $(uname -s)"
  echo -e "  - network node hostname : $(uname -n)"
  echo -e "  - kernel release        : $(uname -r)"
  echo -e "  - kernel version        : $(uname -v)"
  echo -e "  - machine hardware name : $(uname -m)"
  echo -e "  - processor type        : $(uname -p)"
  echo -e "  - hardware platform     : $(uname -i)"
  echo -e "  - operating system      : $(uname -o)"
  echo -e "  - secure boot status    : $(mokutil --sb-state 2>/dev/null || echo "Not available")"

  echo -e "\\n${BRED}Users logged on:$NC"
  echo "  $(w -h)"

  echo -e "\\n${BRED}Current date:$NC"
  echo "  $(date)"

  echo -e "\\n${BRED}Machine stats:$NC"
  echo "  $(uptime | xargs)"

  echo -e "\\n${BRED}Machine BIOS:$NC"
  vm_my_bios

  echo -e "\\n${BRED}Public facing IP Address:$NC"
  echo "  $(vm_my_ip)"
  echo "  $(vm_my_host)"
  echo "  $(vm_my_country)"
  echo "  $(vm_my_ua)"
  echo
}

######################################################################
##
##
##
######################################################################
vm_convert_gif() {
  if [ "$#" -lt 1 ]; then
    echo "Usage: $0 <VIDEO>"
    return 1
  fi

  local input="$1"
  local output="${input%.*}.gif"
  local temp_video="${input%.*}.mp4"
  local palette="/tmp/palette.png"

  local codec="libx265" # libx264 | libx265
  local quality=32      # Lower quality for better file size
  local fps=10          # Reduce fps to optimize GIF size
  local scale=320       # Lower resolution for smaller GIF size

  ffmpeg -y -i "$input" \
    -vaapi_device /dev/dri/renderD128 \
    -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" \
    -map 0:0 -c:v "$codec" \
    -map 0:a? -c:a copy \
    -crf "$quality" \
    -pix_fmt yuv420p \
    -preset fast \
    -r 30 \
    "$temp_video"

  ffmpeg -y -i "$temp_video" -vf "fps=$fps,scale=$scale:-1:flags=lanczos,palettegen=stats_mode=diff" "$palette"
  ffmpeg -y -i "$temp_video" -i "$palette" -filter_complex "fps=$fps,scale=$scale:-1:flags=lanczos[x];[x][1:v]paletteuse" "$output"

  rm "$palette"
}

######################################################################
##
## quick ubuntu: create and remove multipass ubuntu VM
##
######################################################################
vm_quick_ubuntu() {
  if [[ -z "$1" ]]; then
    echo "Usage: vm_quick_ubuntu <VM_NAME_VERSION> [<optional post-creation command>]"
    return 1
  fi

  TMP_CLOUD_INIT=~/vm_quick_ubuntu_cloud_init.yaml
  {
    echo '#cloud-config'
    echo 'packages_update: true'
    echo 'packages_upgrade: true'
    echo 'packages:'
    echo '  - cowsay'
    echo '  - neofetch'
    echo 'ssh_authorized_keys:'
    echo '  - ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJOBsi+JPb9GLFKA83kRpaphBrvb2uM9r0U0S+SPx1Mo ansible-admin'
  } >"$TMP_CLOUD_INIT"

  # Clean up VM name by removing dots and replacing colons with hyphens
  VM_NAME_VERSION=$(echo "$1" | sed 's|\.||g' | tr ':' '-')

  # Launch the VM with multipass
  multipass launch "$1" -n "ubuntu-$VM_NAME_VERSION" -c 2 -d 16G -m 4G --cloud-init "$TMP_CLOUD_INIT" || {
    echo "Failed to launch VM."
    rm "$TMP_CLOUD_INIT"
    return 1
  }

  # Remove cloud-init file after VM creation
  rm "$TMP_CLOUD_INIT"

  # Run an optional post-creation command, default to 'neofetch' if not provided
  multipass exec "ubuntu-$VM_NAME_VERSION" -- sh -c "${2:-neofetch}"
}

vm_quick_ubuntu_rm() {
  if [[ -z "$1" ]]; then
    echo "Usage: vm_quick_ubuntu_rm <VM_NAME_VERSION>"
    return 1
  fi

  # Clean up VM name
  VM_NAME_VERSION=$(echo "$1" | sed 's|\.||g' | tr ':' '-')

  # Stop, delete, and purge the VM
  multipass stop "ubuntu-$VM_NAME_VERSION" || {
    echo "Failed to stop VM."
    return 1
  }
  multipass delete "ubuntu-$VM_NAME_VERSION" || {
    echo "Failed to delete VM."
    return 1
  }
  multipass purge || {
    echo "Failed to purge VM resources."
    return 1
  }

  # Show current list of VMs
  multipass list
}

######################################################################
##
## Create a shortcut for an AppImage with a PNG icon.
##
######################################################################
vm_shortcut_appimage() {
  if [[ "$#" -ne 3 ]]; then
    echo "Usage: $0 <NAME> <APPIMAGE> <PNG>" >&2
    return 1
  fi

  # Parameters
  local name="$1"
  local appimage="$2"
  local image_png="$3"
  local install_dir="/opt/${name}"
  local desktop_entry="/usr/share/applications/${name}.desktop"

  # Create necessary directories and move files
  sudo mkdir -p "$install_dir" || {
    echo "Failed to create directory $install_dir"
    return 1
  }
  sudo mv "$appimage" "$install_dir/${name}.AppImage" || {
    echo "Failed to move AppImage file"
    return 1
  }
  sudo mv "$image_png" "$install_dir/${name}.png" || {
    echo "Failed to move PNG file"
    return 1
  }

  # Set the correct owner and permissions
  sudo chown -R root:root "$install_dir"
  sudo chmod -R 755 "$install_dir"
  sudo chmod 644 "$install_dir/${name}.png"

  # Create Desktop Entry with indentation using printf and tee
  printf "[Desktop Entry]\n\
    Name=%s\n\
    Exec=%s/%s.AppImage\n\
    Icon=%s/%s.png\n\
    Comment=%s\n\
    Type=Application\n\
    Terminal=false\n\
    Encoding=UTF-8\n\
    Categories=Utility;\n" \
    "$name" "$install_dir" "$name" "$install_dir" "$name" "$name" |
    sudo tee "$desktop_entry" >/dev/null

  # Update the desktop database
  sudo update-desktop-database || {
    echo "Failed to update desktop database"
    return 1
  }

  echo "Shortcut for '${name}' created successfully."
}

######################################################################
##
## EXPORT & ALIAS
##
######################################################################
vm_md_to_pdf() {
  if [ -z "$1" ]; then
    echo "Usage: $0 <input_file.md>"
    return 1
  fi

  local input_file="$1"
  local cur_date
  local filename
  local template_path="${2:-$HOME/.config/templates/pandoc-latex-eisvogel.tex}"
  local template_url="https://raw.githubusercontent.com/Wandmalfarbe/pandoc-latex-template/refs/heads/master/eisvogel.tex"

  # Check if the template file exists, if not, download it
  if [ ! -f "$template_path" ]; then
    mkdir -p "$(dirname "$template_path")"
    echo "Template not found locally. Downloading from URL..."
    if ! curl -sf -o "$template_path" "$template_url"; then
      echo "Error: Failed to download the template from '$template_url'."
      return 1
    fi
    echo "Template downloaded successfully."
  fi

  # Check if the input file exists
  if [ ! -f "$input_file" ]; then
    echo "Error: '$input_file' does not exist."
    return 1
  fi

  # Check if pandoc is installed
  if ! command -v pandoc &>/dev/null; then
    echo "Error: pandoc is not installed."
    return 1
  fi

  cur_date=$(date +"%Y-%m-%d")
  filename=$(basename "$input_file" | cut -f 1 -d ".")

  # Check if fc-list command is available
  if ! command -v fc-list &>/dev/null; then
    echo "Error: fc-list is not installed."
    return 1
  fi

  # Font list and checking for available fonts
  local main_font="DejaVu Sans Mono"
  local font_list=("FiraMono Nerd Font Mono" "Hack Nerd Font Mono" "ProggyCleanTTSZ Nerd Font Mono" "TerminessTTF Nerd Font Mono" "JetBrains Mono" "Fira Code" "Consolas" "Courier New")

  for font_check in "${font_list[@]}"; do
    if fc-list | grep -iq "$font_check"; then
      main_font=$font_check
      break
    fi
  done
  echo "Using font: $main_font"

  # Run pandoc to convert markdown to PDF
  pandoc "$input_file" \
    -o "${filename}.pdf" \
    --from markdown \
    --template "$template_path" \
    --pdf-engine=xelatex \
    --listings \
    -V lang=en-GB \
    -V classoption=onside \
    -V book \
    -V date="$cur_date" \
    -V "mainfont:$main_font" \
    -V 'sansfont:DejaVuSans' \
    -V 'monofont:DejaVuSansMono' \
    -V 'mathfont:TeXGyreDejaVuMath-Regular'
}

######################################################################
##
## extract: Extract most known archives with one command
##
######################################################################
vm_extract() {
  if [ -z "$1" ]; then
    echo "Usage: $0 <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|exe|tar.bz2|tar.gz|tar.xz>"
    return 1
  fi

  local file="$1"

  # Check if the file exists
  if [ ! -f "$file" ]; then
    echo "Error: '$file' does not exist."
    return 1
  fi

  # Extract based on file extension
  case "$file" in
  *.tar.bz2 | *.tbz2) tar xjf "$file" ;;
  *.tar.gz | *.tgz) tar xzf "$file" ;;
  *.tar.xz) tar xJf "$file" ;;
  *.lzma) unlzma "$file" ;;
  *.bz2) bunzip2 "$file" ;;
  *.rar) unrar x -ad "$file" ;;
  *.gz) gunzip "$file" ;;
  *.tar) tar xf "$file" ;;
  *.zip) unzip "$file" ;;
  *.Z) uncompress "$file" ;;
  *.7z) 7z x "$file" ;;
  *.xz) unxz "$file" ;;
  *.exe) cabextract "$file" ;;
  *) echo "Error: Unknown archive method for '$file'" ;;
  esac
}

######################################################################
##
## encrypt: Encrypt files using known archives with a single command
##
######################################################################
vm_encrypt() {
  if [ $# -lt 2 ]; then
    echo "Usage: $0 <rar|7z> <file_or_path> [keyword 'sec'|password]"
    return 1
  fi

  local type="$1"
  local file_or_path="$2"
  local password_option=""

  # Validate type and set password_option
  case "$type" in
  rar)
    if [ -n "$3" ]; then
      # If 'sec' keyword is provided, set password for RAR
      password_option="$([[ "$3" == "sec" ]] && echo "-hp")${3#sec}"
    fi
    ;;
  7z)
    if [ -n "$3" ]; then
      # If 'sec' keyword is provided, set password for 7z
      password_option="$([[ "$3" == "sec" ]] && echo "-p")${3#sec}"
    fi
    ;;
  *)
    echo "Error: Unsupported compression type '$type'. Supported types are 'rar' and '7z'."
    return 1
    ;;
  esac

  # Check if the file or path exists
  if [ ! -e "$file_or_path" ]; then
    echo "Error: '$file_or_path' is not a valid file or path."
    return 1
  fi

  # Perform the compression and encryption
  case "$type" in
  rar)
    if [ -n "$password_option" ]; then
      rar a "$password_option" "${file_or_path}.rar" "$file_or_path"
    else
      rar a "${file_or_path}.rar" "$file_or_path"
    fi
    ;;
  7z)
    if [ -n "$password_option" ]; then
      7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=32m -ms=on -mhe=on "$password_option" "${file_or_path}.7z" "$file_or_path"
    else
      7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=32m -ms=on -mhe=on "${file_or_path}.7z" "$file_or_path"
    fi
    ;;
  esac
}
